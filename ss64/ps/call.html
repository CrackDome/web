<!doctype html><html lang="en">

<!-- Mirrored from ss64.com/ps/call.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Aug 2020 00:06:07 GMT -->

<head><meta charset="UTF-8">
<meta name="viewport" content="width=768, initial-scale=1">
<link rel="STYLESHEET" href="../main.css" type="text/css">
<title>Call operator - Run - PowerShell - SS64.com</title>
</head><body><!-- #BeginLibraryItem "/Library/head_ps.lbi" --><div id="tnav"><ul>
<li class="tbtn"><a href="../index.html">SS64</a></li>
<li class="tbtn"><a href="index.html">PowerShell <svg viewBox="0 0 13 20.1" width="13" height="13" style="transform: rotate(0deg);"><path d="M0 2.9l7.2 7.2-7.1 7.1L3 20.1l7.1-7.1 2.9-2.9L2.9 0 0 2.9"></path></svg></a></li>
<li class="tbtn"><a href="syntax.html">How-to <svg viewBox="0 0 13 20.1" width="13" height="13" style="transform: rotate(0deg);"><path d="M0 2.9l7.2 7.2-7.1 7.1L3 20.1l7.1-7.1 2.9-2.9L2.9 0 0 2.9"></path></svg></a></li>
<li><div id="search"><form action="https://www.google.com/search" method="get">
<input type="text" name="q" id="q" size="27" maxlength="255">
<input class="submit" value="Search" id="btn" type="submit">
<input type="hidden" name="sitesearch" value="ss64.com/ps/"></form></div></li>
</ul></div><!-- #EndLibraryItem --><h1>&amp;</h1> 
<p>The <abbr title="confusingly also known as the Command Invocation Operator">call</abbr> <a href="syntax-operators.html">operator</a> (&amp;) allows you to execute a command, script or function. </p>
<p>Many times you can  execute a command by just typing its name, but this will only run if the command is in the environment path. Also if the command (or the path) contains a space then this will fail. Surrounding a command with quotes will make PowerShell treat it as a string, so in addition to quotes, use the &amp; call operator to force PowerShell to treat the string as a command to be executed. </p>
<pre>Syntax
      <b>&amp;</b> &quot;[<i>path</i>] <i>command&quot;</i> [<i>arguments</i>]

Key:
    <i>command</i>   An executable filename (.exe), script or function.

   <i>arguments</i>  The call operator will only handle a single command.
              Any arguments may follow the called command.

              If you are calling a non-PowerShell command/utility then the command 
              and any arguments should be surrounded in quotes if needed 
              due to spaces/long filenames:

              &amp; &quot;C:\batch\someutil.exe&quot; test 123 &quot;long path to\some file.txt&quot; </pre>
<h2>Precedence of commands:</h2>
<blockquote>
<pre> Alias &gt; Function &gt; Filter &gt; Cmdlet &gt; Application &gt; ExternalScript &gt; Script
   Highest priority .................................... Lowest priority </pre>
<p>If you need to run a specific type of command which may not be the highest priority use <a href="get-command.html">Get-Command</a>. For example if you have an external command called Ping and a function also called ping, normally the function will be run as it has higher priority, <span class="code">Get-Command -commandType Application Ping</span> will return the external application instead.</p>
</blockquote>
<h2>Script blocks<a id="scriptblocks"></a></h2>
<blockquote>
<p>Several commands, statements or expressions (a <a href="syntax-scriptblock.html">script block</a>) can be stored in a variable: <span class="code">$myVar = { <i>Scriptblock</i> } </span><br>
Then execute the script using <span class="code">&amp;</span> <br>
<span class="code">PS C:\&gt; &amp; $myVar<br>
</span>or even without the variable<span class="code">: <br>
PS C:\&gt; &amp; {<i>Scriptblock</i>}<br>
</span><br>
This usage (calling a script block) is similar to using <a href="invoke-expression.html">Invoke-Expression</a> to run a set of commands but has a key difference in that the <span class="code">&amp;</span> call operator will create an additional <a href="syntax-scopes.html">scope</a>, while Invoke-Expression will not. </p>
</blockquote>
<h2>Start-Process</h2>
<blockquote>
<p>If you need to capture a return value from the new process, store the output the process generates ( stdout and stderr ) and control the  style or visibility of the Window, then use <a href="start-process.html">Start-Process</a> which makes all those options available.</p>
</blockquote>
<h2>EchoArgs</h2>
<blockquote>
<p>EchoArgs is a simple utility that spits out the arguments it receives. This is very useful for testing, just replace the program name in your script with EchoArgs.exe to see which parameters are being passed.<br>
EchoArgs is part of the <a href="../links/pslinks.html">PowerShell Community Extensions</a>, but you can download a copy of <a href="EchoArgs.exe">EchoArgs.exe</a> right here.</p>
</blockquote>
<h2>Dot-Sourcing</h2>
<blockquote>
<p>Invoking a command (either directly or with the call operator) will create a child scope that will be thrown away when the command exits. If the command/script changes a global variable those changes will be lost when the scope ends. <br>
To avoid this and preserve any changes made to global variables you can '<a href="source.html">dot</a>' the script which will execute the script in the current <a href="syntax-scopes.html">scope</a>.<br>
<span class="code">PS C:\&gt; <b>.</b> C:\scripts\myscript.ps1<br>
</span><span class="code">PS C:\&gt; <b>.</b> ./script64.ps1</span></p>
<p>Dot sourcing runs a function or script within the current <a href="syntax-scopes.html">scope</a>.<br>
unlike the <a href="call.html">call operator</a> (&amp;) which will run a function or script, within a separate scope. </p>
<p><span class="code">PS C:\&gt; $x=1<br>
PS C:\&gt; &amp;{$x=2};$x<br>
1<br>
PS C:\&gt;</span> . <span class="code">{$x=2};$x<br>
2</span> </p>
</blockquote>
<p><b>Examples</b></p>
<p>Run the script mycommand.exe:<br>
<span class="code">PS C:\&gt; <b>&amp; </b>&quot;C:\Program files\mycommand.exe&quot;</span><br>
<br>
 or using a variable:<br>
<span class="code">PS C:\&gt; $program = &quot;C:\Program files\mycommand.exe&quot;<br>
PS C:\&gt; <b>&amp; </b>$program</span><br>
<br>
 Run a command + options, note that we just pass the parameter as a separate string on the same line:<br>
</p>
<p><span class="code">PS C:\&gt; $program = "Get-ChildItem"<br>
 PS C:\&gt; <b>&</b> $program "*.txt"<br>
> Directory listing</span><br>
</p>
<p>Call one PowerShell script from another script saved in the same directory:</p>
<p><span class="code">#Requires -Version 3.0 <br>
&amp; &quot;$PSScriptRoot\<a href="syntax-consolesize.html">set-consolesize</a>.ps1&quot; -height 25 -width 90</span></p>
<p>Run a specific non-PowerShell command via <a href="get-command.html">Get-Command</a>:</p>
<p> <span class="code">PS C:\&gt; $myPing = Get-Command -commandType Application Ping.exe<br>
PS C:\&gt; <b>&amp; </b>$myPing</span><br>
<br>
Run a scriptblock (original value of variable is preserved):<br>
<span class="code">PS C:\&gt; $i = 2<br>
PS C:\&gt; $scriptblock = { $i=5; echo $i }<br>
PS C:\&gt; <b>&</b> $scriptblock<br>
5<br>
PS C:\&gt; $i<br>
2</span><br>
<br>
 With Invoke-expression the original value of the variable would be  changed, because it runs within the same <a href="syntax-scopes.html">scope</a>:<br>
<span class="code">PS C:\&gt; invoke-expression ' $i=5; echo $i '<br>
5<br>
PS C:\&gt; $i<br>
5</span><br>
</p>

<p><i class="quote">#You went away, And I wonder where you will stay, My little runaway, Run, run, run, run, runaway# ~ Dell Shannon</i></p>
<p><b>Related PowerShell Cmdlets:</b></p>
<p class="space"><a href="source.html">. (source)</a> - Run a command script in the current shell (persist variables and functions).<br>
<a href="syntax-run.html">Run a PowerShell script</a> - More examples of running scripts, .Bat, .vbs, dot-sourcing, elevation.<br>
<a href="invoke-command.html">Invoke-Command</a> -   Run commands on local and remote computers.<br>
<a href="invoke-expression.html">Invoke-Expression</a> - Run a PowerShell expression.<br>
<a href="start-process.html">Start-Process</a> -  Start one or more processes, optionally as a specific user.<br>
<a href="stop-parsing.html">--%</a> - Stop parsing input as PowerShell commands.<br>
<a href="syntax-operators.html">PowerShell Operators</a> - SubExpressions Syntax.<br>
<a href="https://rkeithhill.wordpress.com/2007/11/24/effective-powershell-item-10-understanding-powershell-parsing-modes/">Keith Hill's blog</a> - Command parsing mode vs Expression parsing mode.</p><!-- #BeginLibraryItem "/Library/foot_ps.lbi" --><p><script async src="../../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
<!-- PowerShell300 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-6140977852749469"
     data-ad-slot="6253539900"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</p>
<hr>
<div id=bl>&nbsp;</div>
<div id=br>Copyright &copy; 1999-2020 <a href="../index.html">SS64.com</a><br>
Some rights reserved</div><!-- #EndLibraryItem --></body>

<!-- Mirrored from ss64.com/ps/call.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 29 Aug 2020 00:06:08 GMT -->
</html>
